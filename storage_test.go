package main

import (
	"bytes"
	"fmt"
	"io"
	"testing"
)

// newStore initializes a new Store instance for testing purposes.
// It uses the CASPathTransformFunc for generating content-addressable storage paths.
func newStore() *Store {
	opts := StoreOpts{
		PathTransformFunc: CASPathTransformFunc, // Use CAS path transform function
	}
	return NewStore(opts) // Create and return a new Store with the specified options
}

// teardown clears the storage after each test to ensure a clean environment.
// It is called using defer to run after the test completes.
func teardown(t *testing.T, s *Store) {
	if err := s.Clear(); err != nil { // Clear all files in the store's root directory
		t.Error(err) // Report any error that occurs during teardown
	}
}

// TestPathTransformFunc verifies that the CASPathTransformFunc correctly transforms keys
// into hashed filenames and directory paths.
func TestPathTransformFunc(t *testing.T) {
	key := "mombestpicture"              // Example key to be transformed
	pathKey := CASPathTransformFunc(key) // Apply the transform function

	// Expected filename and pathname based on the SHA-1 hash of the key
	expectedFilename := "cf5d4b01c4d9438c22c56c832f83bd3e8c6304f9"
	expectedPathname := "cf5d4/b01c4/d9438/c22c5/6c832/f83bd/3e8c6/304f9"

	// Verify the filename generated by the transform function matches the expected filename
	if pathKey.Filename != expectedFilename {
		t.Errorf("have %s want %s", pathKey.Filename, expectedFilename)
	}

	// Verify the pathname generated by the transform function matches the expected pathname
	if pathKey.Pathname != expectedPathname {
		t.Errorf("have %s want %s", pathKey.Pathname, expectedPathname)
	}
}

// TestStore tests the basic functionality of the Store, including writing, reading, and deleting files.
func TestStore(t *testing.T) {
	s := newStore()      // Initialize a new store for testing
	id := generateID()   // Generate a unique ID for the test
	defer teardown(t, s) // Ensure teardown runs after the test completes to clean up

	for i := 0; i < 100; i++ { // Test with 100 different keys
		key := fmt.Sprintf("foo_%d", i)      // Generate a unique key for each iteration
		data := []byte("Some Jpeg Bytes...") // Example data to store in the file

		// Write data to the store and check for errors
		if _, err := s.writeStream(id, key, bytes.NewReader(data)); err != nil {
			t.Error(err) // Report any error that occurs during writing
		}

		// Read the content of the file from the store
		_, r, err := s.Read(id, key)
		if err != nil {
			t.Error(err) // Report any error that occurs during reading
		}

		// Read all bytes from the reader and compare with the original data
		b, _ := io.ReadAll(r)
		if string(b) != string(data) {
			t.Errorf("want %s have %s", data, b) // Report if the read data does not match the expected data
		}
		fmt.Println(string(b)) // Print the content of the file to the console (optional)

		// Check if r implements the io.Closer interface and close it if it does
		if closer, ok := r.(io.Closer); ok {
			closer.Close() // Close the reader to release resources
		}

		// Delete the file from the store and check for errors
		if err := s.Delete(id, key); err != nil {
			t.Error(err) // Report any error that occurs during deletion
		}

		// Verify that the file no longer exists in the store
		if ok := s.Has(id, key); ok {
			t.Errorf("expected to NOT have key %s", key) // Report if the key still exists
		}
	}
}
